package opcodes

import (
	"fmt"
	"strings"

	"github.com/git-town/git-town/v21/internal/cli/colors"
	"github.com/git-town/git-town/v21/internal/config/configdomain"
	"github.com/git-town/git-town/v21/internal/forge/forgedomain"
	"github.com/git-town/git-town/v21/internal/git/gitdomain"
	"github.com/git-town/git-town/v21/internal/messages"
	"github.com/git-town/git-town/v21/internal/vm/shared"
	. "github.com/git-town/git-town/v21/pkg/prelude"
)

type ProposalLineageCreate struct {
	Branch                  gitdomain.LocalBranchName
	ProposalLineageIn       configdomain.ProposalLineageIn
	undeclaredOpcodeMethods `exhaustruct:"optional"`
}

func (self *ProposalLineageCreate) Run(args shared.RunArgs) error {
	if currentBranchType := args.Config.Value.BranchType(self.Branch); currentBranchType == configdomain.BranchTypeMainBranch || currentBranchType == configdomain.BranchTypePerennialBranch {
		s := strings.Builder{}
		s.WriteString("\n")
		s.WriteString(colors.BoldCyan().Styled(fmt.Sprintf(messages.ProposalLineageUnsupportedForBranchType, currentBranchType)))
		s.WriteString("\n")
		fmt.Print(s.String())
		return nil
	}
	connector, hasConnector := args.Connector.Get()
	if !hasConnector {
		return forgedomain.UnsupportedServiceError()
	}

	findProposalFn, hasFindProposalFn := connector.FindProposalFn().Get()
	if !hasFindProposalFn {
		return fmt.Errorf("connector does not support finding proposals")
	}

	targetBranch := args.Config.Value.NormalConfig.Lineage.Parent(self.Branch)
	if targetBranch.IsNone() {
		return fmt.Errorf("current branch has no parent. Cannot find proposal to create lineage")
	}

	proposalData, err := findProposalFn(self.Branch, targetBranch.GetOrPanic())
	if err != nil {
		return err
	}

	if proposalData.IsNone() {
		return fmt.Errorf("current branch has no proposal")
	}

	builder := configdomain.NewProposalLineageBuilder(connector, args.Config.Value.MainAndPerennials()...)
	lineageInformation := args.Config.Value.NormalConfig.Lineage.BranchLineage(self.Branch)
	for _, curr := range lineageInformation {
		currParent := args.Config.Value.NormalConfig.Lineage.Parent(curr)
		builder.AddBranch(curr, currParent)
	}

	switch self.ProposalLineageIn {
	case configdomain.ProposalLineageInTerminal:
		stackLineage := builder.Build(
			configdomain.WithCurrentBranch(self.Branch),
			configdomain.WithCurrentBranchIndicator("*"),
			configdomain.WithIndentMarker("â€¢"),
			configdomain.WithProposalLineageIn(self.ProposalLineageIn),
			configdomain.WithStringBeforeStackDisplay("Proposal Stack Lineage:\n\n"),
		)
		if stackLineage.IsNone() {
			return nil
		}
		fmt.Print(stackLineage.GetOrPanic())
		return nil
	case configdomain.ProposalLineageOperationInProposalBody:
		explainationText := "Current dependencies on/for this pull-request\n\n"
		if args.Config.Value.NormalConfig.ForgeType.GetOrDefault() == forgedomain.ForgeTypeGitLab {
			explainationText = strings.ReplaceAll(explainationText, "pull-request", "merge-request")
		}

		stackLineage := builder.Build(
			configdomain.WithCurrentBranch(self.Branch),
			configdomain.WithCurrentBranchIndicator(":point_left:"),
			configdomain.WithIndentMarker("-"),
			configdomain.WithProposalLineageIn(self.ProposalLineageIn),
			configdomain.WithStringBeforeStackDisplay("\n-------------------------\n"),
			configdomain.WithStringBeforeStackDisplay(explainationText),
			configdomain.WithStringAfterStackDisplay("\n\nStack generated by [Git-Town](https://github.com/git-town/git-town)\n"),
		)
		if stackLineage.IsNone() {
			return nil
		}
		proposalDataUnwrapped := proposalData.GetOrPanic().Data
		currentBody := proposalDataUnwrapped.Data().Body.GetOrDefault()
		lineageString := stackLineage.GetOrDefault()

		// Update body with lineage using our marker-based approach
		updatedBody := updateProposalBodyWithStackLineage(currentBody, lineageString)

		op := &ProposalUpdateBody{
			Proposal:    proposalDataUnwrapped,
			UpdatedBody: Some(updatedBody),
		}
		return op.Run(args)
	default:
		return nil
	}
	return nil
}

func updateProposalBodyWithStackLineage(currentBody, lineageContent string) string {
	startMarker := "<!-- branch-stack -->"
	endMarker := "<!-- branch-stack-end -->"

	// Create the full lineage section with both markers
	lineageSection := startMarker + "\n" + lineageContent + "\n" + endMarker

	// Find the start marker
	startIndex := strings.Index(currentBody, startMarker)
	if startIndex != -1 {
		// Find where our section ends
		afterStart := currentBody[startIndex:]

		// Look for the end marker
		endMarkerIndex := strings.Index(afterStart, endMarker)

		var beforeSection, afterSection string
		beforeSection = currentBody[:startIndex]

		if endMarkerIndex != -1 {
			// End marker found - replace everything including the end marker
			afterSection = afterStart[endMarkerIndex+len(endMarker):]
		} else {
			// No end marker - preserve everything after our content
			// Find the end of the lineage content (look for double newline or end of string)
			contentAfterMarker := afterStart[len(startMarker):]

			// Try to find where the old lineage content ends
			// Look for the next section (typically starts with \n\n)
			doubleNewlineIndex := strings.Index(contentAfterMarker, "\n\n")
			if doubleNewlineIndex != -1 {
				afterSection = contentAfterMarker[doubleNewlineIndex:]
			} else {
				// No clear boundary found, replace everything
				afterSection = ""
			}
		}

		return beforeSection + lineageSection + afterSection
	}

	// Marker doesn't exist - append it
	if currentBody != "" {
		return currentBody + "\n\n" + lineageSection
	}
	return lineageSection
}
