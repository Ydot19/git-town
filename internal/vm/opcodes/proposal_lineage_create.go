package opcodes

import (
	"fmt"
	"strings"

	"github.com/git-town/git-town/v21/internal/config/configdomain"
	"github.com/git-town/git-town/v21/internal/forge/forgedomain"
	"github.com/git-town/git-town/v21/internal/git/gitdomain"
	"github.com/git-town/git-town/v21/internal/vm/shared"
	. "github.com/git-town/git-town/v21/pkg/prelude"
)

type ProposalLineageCreate struct {
	Branch                  gitdomain.LocalBranchName
	ProposalLineageIn       configdomain.ProposalLineageIn
	undeclaredOpcodeMethods `exhaustruct:"optional"`
}

func (self *ProposalLineageCreate) Run(args shared.RunArgs) error {
	connector, hasConnector := args.Connector.Get()
	if !hasConnector {
		return forgedomain.UnsupportedServiceError()
	}

	mainAndPerennials := args.Config.Value.MainAndPerennials()
	builder := configdomain.NewProposalStackLineageBuilder(connector, args.Config.Value.NormalConfig.Lineage, mainAndPerennials...)
	lineageTree := configdomain.NewLineageTree(self.Branch, args.Config.Value.NormalConfig.Lineage, mainAndPerennials)
	for _, curr := range lineageTree.Branches() {
		builder.AddBranch(curr)
	}

	switch self.ProposalLineageIn {
	case configdomain.ProposalLineageInTerminal:
		stackLineage := builder.Build(
			lineageTree,
			configdomain.WithCurrentBranch(self.Branch),
			configdomain.WithCurrentBranchIndicator("*"),
			configdomain.WithIndentMarker("â€¢"),
			configdomain.WithProposalLineageIn(self.ProposalLineageIn),
			configdomain.WithStringBeforeStackDisplay("Proposal Stack Lineage:\n\n"),
		)
		if stackLineage.IsNone() {
			return nil
		}
		fmt.Print(stackLineage.GetOrPanic())
		return nil
	case configdomain.ProposalLineageOperationInProposalBody:
		proposalData := builder.GetProposal(self.Branch)

		if proposalData.IsNone() {
			fmt.Println("current branch has no proposal to sync")
			return nil
		}
		explainationText := "Current dependencies on/for this pull-request\n\n"
		if args.Config.Value.NormalConfig.ForgeType.GetOrDefault() == forgedomain.ForgeTypeGitLab {
			explainationText = strings.ReplaceAll(explainationText, "pull-request", "merge-request")
		}

		stackLineage := builder.Build(
			lineageTree,
			configdomain.WithCurrentBranch(self.Branch),
			configdomain.WithCurrentBranchIndicator(":point_left:"),
			configdomain.WithIndentMarker("-"),
			configdomain.WithProposalLineageIn(self.ProposalLineageIn),
			configdomain.WithStringBeforeStackDisplay("\n-------------------------\n"),
			configdomain.WithStringBeforeStackDisplay(explainationText),
			configdomain.WithStringAfterStackDisplay("\n\nStack generated by [Git-Town](https://github.com/git-town/git-town)\n"),
		)
		if stackLineage.IsNone() {
			return nil
		}

		proposalDataUnwrapped := proposalData.GetOrPanic()
		currentBody := proposalDataUnwrapped.Body.GetOrDefault()
		lineageString := stackLineage.GetOrDefault()

		// Update body with lineage using our marker-based approach
		updatedBody := updateProposalBodyWithStackLineage(currentBody, lineageString)

		op := &ProposalUpdateBody{
			Proposal:    proposalDataUnwrapped,
			UpdatedBody: Some(updatedBody),
		}
		return op.Run(args)
	default:
		return nil
	}
}

func updateProposalBodyWithStackLineage(currentBody, lineageContent string) string {
	startMarker := "<!-- branch-stack -->"
	endMarker := "<!-- branch-stack-end -->"

	// Create the full lineage section with both markers
	lineageSection := startMarker + "\n" + lineageContent + "\n" + endMarker

	// Find the start marker
	startIndex := strings.Index(currentBody, startMarker)
	if startIndex != -1 {
		// Find where our section ends
		afterStart := currentBody[startIndex:]

		// Look for the end marker
		endMarkerIndex := strings.Index(afterStart, endMarker)

		var beforeSection, afterSection string
		beforeSection = currentBody[:startIndex]

		if endMarkerIndex != -1 {
			// End marker found - replace everything including the end marker
			afterSection = afterStart[endMarkerIndex+len(endMarker):]
		} else {
			// No end marker - preserve everything after our content
			// Find the end of the lineage content (look for double newline or end of string)
			contentAfterMarker := afterStart[len(startMarker):]

			// Try to find where the old lineage content ends
			// Look for the next section (typically starts with \n\n)
			doubleNewlineIndex := strings.Index(contentAfterMarker, "\n\n")
			if doubleNewlineIndex != -1 {
				afterSection = contentAfterMarker[doubleNewlineIndex:]
			} else {
				// No clear boundary found, replace everything
				afterSection = ""
			}
		}

		return beforeSection + lineageSection + afterSection
	}

	// Marker doesn't exist - append it
	if currentBody != "" {
		return currentBody + "\n\n" + lineageSection
	}
	return lineageSection
}
